---
title: "「星座づくり」(1) 概要"
---

## なにこれ

ランダムに配置される星をつないで、星座を描くゲームです。
描いた星座の形をもとに、AI に星座名と物語を考えてもらいます。

AI はコスト重視で`Groq API`を採用しました。

- 動作確認
  - unityroom
    - <https://unityroom.com/games/seiza-zukuri>
  - GitHub
    - <https://github.com/ushibutatory/game-stella_generator-pages>

## 使用ライブラリ、環境など

※アーキテクチャに関するもののみ記載

### Unity

- `UniTask`
  - 非同期処理のため
- `MessagePipe`
  - Pub/Sub パターン実装のため
  - 主に以下の用途で使用しています。
    - レイヤー間の通信、特に「メソッドの戻り値（＝実行結果）」に該当する処理。
    - プレゼンテーション層における、オブジェクト間の通信。
- `VContainer`
  - DI コンテナ
- `R3`
  - Rx ライブラリ
  - 主に UI コンポーネントのイベント（ボタンクリック等）のハンドリングに使用。

### API

- `AWS Lambda` + `API Gateway`
  - `Groq API` キー及びプロンプトを秘匿するため
- Node.js
- `Groq SDK`
  - `Groq API` を実行するため

## アーキテクチャ

クリーンアーキテクチャを意識しました。
また、命名統一のため、用語を自分の言葉で再定義したりしました。

ちゃんとクリーンアーキテクチャになってないところもあります。後述します。

![アーキテクチャ](https://github.com/ushibutatory/tech-blogs/blob/main/images/20250822_022612.png?raw=true)

### ドメイン層

- 責務
  - 状態の整合性を担保すること。
    - 「ドメインのルール」を常に守っていることを保証する。
    - 外部からの操作によって整合性を失わせることはできない。
- 提供機能
  - **Entity**
    - 「定義」と「状態」を持つモデル。
    - 「定義」はエンティティ生成時のパラメータとなり、生成後は変更されない。
    - 「状態」はエンティティ生成時に初期化され、適宜変更される可能性がある。
      - 「状態」は常に整合性が保たれている。
  - **ValueObject**
    - 「定義」を持つモデル。
      - いわゆる「値」だが、Entity の説明と比較するために敢えて「定義」と呼ぶ。
    - 「状態」を持たない（つまりイミュータブルである）。
  - **Function**（インタフェース）
    - 「定義」や「状態」を持たない、単発の処理。
    - 入力に対して処理を行い、結果を返す。
    - いわゆる「ドメインサービス」だが、今回は私個人のイメージしやすさを重視して「Function」とした。
      （サービスという名前にすると副作用を持たせたり責務過多にしたりしそうなので……）
  - **Function**（クラス）
    - Function の中でも、外部サービスに依存しないもの。
    - 今回のゲームで言えば「指定された個数の星を、ランダムな座標に生成する」。
  - **Repository**（インタフェース）
    - Entity や ValueObject の格納先。
      - Repository 自体が内部状態を持つこともあれば、ドメインを参照することもあるし、インフラ層を経由して外部と通信することもある。Repository インタフェースはそれらの実装を隠蔽する。
  - **Repository**（実装クラス）
    - Repository の中でも外部ストレージや外部サービスを使用せずメモリだけで管理するもの。
    - 今回のゲームで言えば「ランダム生成された星エンティティのリポジトリ」。
  - **DomainEvent**
    - 状態が更新された際に通知する。
    - 次項で詳細記述

### アプリケーション層

- 責務
  - プレゼンテーション層からの要求にあわせて、ドメイン層に更新を要求する。
  - ドメイン操作を組み合わせてユースケースを表現する。
  - アプリケーションを構成する様々な状態の参照を提供する。
- 提供機能
  - **UseCase**
    - 取得系ユースケース
      - 戻り値でデータ（DTO）を返す。
      - エンティティから DTO への変換は各ユースケースで行う。
    - 更新系ユースケース
      - ドメインを操作する。
      - 戻り値は原則なしとする（処理結果を返さない）。
        - 更新結果を必要とするコンポーネントがユースケース呼び出し元のみとは限らないため。
        - 下記のアプリケーションイベントで結果を通知する。必要に応じてデータ（DTO）を同梱する。
  - **DTO**
    - Data Transfer Object。
    - アプリケーション層からプレゼンテーション層へ値を渡すための構造体。
      - イミュータブル。
    - ユースケース固有の型はユースケース内で定義するが、複数のユースケースで汎用的に使用可能な型はここで定義する。
  - **ApplicationEvent**
    - ユースケース実行が完了または失敗した際に通知する。
    - 次項で詳細記述

### プレゼンテーション層

- 責務
  - UI イベントをハンドリングし、アプリケーション層に処理を要求する（ユースケースを実行する）。
  - モデルを画面上に描画する。
- 提供機能
  - **Component**
    - MonoBehaviour を継承したコンポーネント。
    - UI イベントのハンドリングやアプリケーション層への要求、他コンポーネントへの処理要求を行う。
  - **PresentationEvent**
    - コンポーネント間の通信用メッセージ（効果音を再生する、ダイアログを表示する、等）。
    - 次項で詳細記述

### コア層（図には描いていない）

- 責務
  - Logging 機能や、汎用的な構造体や列挙型、拡張メソッドなどを定義する。

### インフラ層

- 責務
  - データの永続化
  - 外部サービスとの接続、通信
- 提供機能
  - `Repository`、`Function`の実装
    - `Addressables` へのアクセス
    - `Groq API` へのアクセス

## 所感

### 反省点

「クリーンアーキテクチャじゃない」ところがいくつかあります。

- ドメイン層にリポジトリが含まれている。
  - 具体的には、`Addressables` を外部サービスとみなして実装しました。
- ドメイン層が外部サービスに依存している。
  - 具体的には、ドメイン層の `Function` 内で `Groq API` を実行しています。

シンプルのためにこうした、という言い訳はありますし、実際これで混乱することは少なかったのですが、「こんなものはクリーンアーキテクチャではない」と言われたら、そうですね。

とはいえ、オレオレアーキテクチャとして今回の開発ではそこまで破綻していませんでした。規模やゲームジャンルが変わればまた違う評価になるかもしれません。

「今回のこの規模のゲーム開発では大きな問題にはならなかった」という結論です。

### よかった点

機能追加や改修を「ユースケース」という分かりやすい単位で考えて進められたのが良かったです。
